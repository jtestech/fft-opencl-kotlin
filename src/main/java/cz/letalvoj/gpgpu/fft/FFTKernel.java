package cz.letalvoj.gpgpu.fft;

import com.amd.aparapi.Kernel;

/**
 * The kernel must be implemented in Java, because the Aparapi depends on some special patterns in bytecode generated by
 * Oracle java compiler.
 */
public class FFTKernel extends Kernel {

    private final float[] inputRe, inputIm;
    private final float[] outputRe, outputIm;
    private final float[] weightsIm, weightsRe;
    final int N, logN;

    public FFTKernel(int N) {
        this.inputRe = new float[N];
        this.inputIm = new float[N];
        this.outputRe = new float[N];
        this.outputIm = new float[N];
        this.weightsIm = new float[N / 2];
        this.weightsRe = new float[N / 2];
        this.N = N;
        this.logN = Integer.numberOfTrailingZeros(N);

        checkLengths();
        initWeights();
    }

    public void setInputValue(int i, float re, float im) {
        int shift = 1 + Integer.numberOfLeadingZeros(N);
        int j = Integer.reverse(i) >>> shift;

        inputRe[j] = re;
        inputIm[j] = im;
    }

    public float[] getResultRe() {
        return (logN % 2 == 1) ? outputRe : inputRe;
    }

    public float[] getResultIm() {
        return (logN % 2 == 1) ? outputIm : inputIm;
    }

    private void checkLengths() {
        if (Integer.highestOneBit(N) != N)
            throw new RuntimeException("N is not a power of 2: " + N);

        if (inputRe.length != N || inputIm.length != N || outputRe.length != N || outputIm.length != N)
            throw new RuntimeException("Expected all input arrays to have length " + N);
    }

    private void initWeights() {
        for (int i = 0; i < N / 2; i++) {
            double angle = -2 * i * Math.PI / N;

            weightsRe[i] = (float) Math.cos(angle);
            weightsIm[i] = (float) Math.sin(angle);
        }
    }

    @Override
    public void run() {
        int pass = getPassId();
        int gId = getGlobalId();

        if (pass % 2 == 0) {
            butterfly(pass, gId, inputRe, inputIm, outputRe, outputIm);
        } else {
            butterfly(pass, gId, outputRe, outputIm, inputRe, inputIm);
        }
    }

    public void butterfly(int pass, int gId, float[] inRe, float[] inIm, float[] outRe, float[] outIm) {
        int passBit = 1 << pass;
        int fftWidth = passBit * 2;

        int first = gId & (~passBit);
        int second = gId | passBit;
        int signum = (gId == first) ? 1 : -1;

        int butterflyNumber = pass == 0 ? 0 : gId % (fftWidth / 2);
        int weight = (butterflyNumber * N) / fftWidth;

        float wRe = weightsRe[weight];
        float wIm = weightsIm[weight];

        outRe[gId] = inRe[second] * wRe - inIm[second] * wIm;
        outIm[gId] = inRe[second] * wIm + inIm[second] * wRe;

        outRe[gId] *= signum;
        outIm[gId] *= signum;

        outRe[gId] += inRe[first];
        outIm[gId] += inIm[first];
    }

}



package cz.letalvoj.gpgpu;

import java.util.Arrays;

public class FFT {

    // compute the FFT of x[], assuming its length is a power of 2
    public static void fft(Complex[] x) {

        // test data
        // input = 0.424166759713807	0.507858284661118	0.0855157970900440	0.262482234698333	0.801014622769739	0.0292202775621463	0.928854139478045	0.730330862855453	0.488608973803579	0.578525061023439	0.237283579771521	0.458848828179931	0.963088539286913	0.546805718738968	0.521135830804002	0.231594386708524	0.488897743920167	0.624060088173690	0.679135540865748	0.395515215668593	0.367436648544477	0.987982003161633	0.0377388662395521	0.885168008202475	0.913286827639239	0.796183873585212	0.0987122786555743	0.261871183870716	0.335356839962797	0.679727951377338	0.136553137355370	0.721227498581740	0.106761861607241	0.653757348668560	0.494173936639270	0.779051723231275	0.715037078400694	0.903720560556316	0.890922504330789	0.334163052737496	0.698745832334795	0.197809826685929	0.0305409463046367	0.744074260367462	0.500022435590201	0.479922141146060	0.904722238067363	0.609866648422558	0.617666389588455	0.859442305646212	0.805489424529686	0.576721515614685	0.182922469414914	0.239932010568717	0.886511933076101	0.0286741524641061	0.489901388512224	0.167927145682257	0.978680649641159	0.712694471678914	0.500471624154843	0.471088374541939	0.0596188675796392	0.681971904149063
        // output = 33.5071946248834 + 0.00000000000000i	-1.13101735688985 + 0.406729449475790i	-1.48465071113273 - 0.819634065690065i	-0.142808450511818 + 0.239642689082386i	-0.212349451108356 - 1.14693228377951i	-0.273998419566102 + 4.28316854094621i	-2.72015730531285 - 1.08259050424059i	-0.264071761278926 - 0.431653669711722i	-0.0815223578179583 + 0.945616250359873i	0.461676582810861 - 1.32026551934167i	1.70013864954576 + 1.77578688515317i	2.20981585489899 - 1.97046476067149i	-0.0841990783480326 - 2.19317445383265i	1.74947644652770 + 0.944017569300557i	0.155572955829434 + 1.55773538196422i	0.447819021167126 + 3.33503556085975i	0.817796364815585 - 0.309707024348210i	-1.67813971614456 - 0.978004277157783i	1.81098334556302 + 0.143977389053291i	2.40905461788825 - 0.396050137265195i	-1.25211463612889 + 0.875583758727025i	1.99945612556177 - 0.956895757453615i	1.45437797145914 - 0.374414601180126i	-2.45040875763492 - 2.17708811713246i	-0.193106604192182 - 0.967434476506570i	0.376246798847378 + 0.895446879090657i	-3.69406959265168 + 2.13615561430979i	-0.228744126780665 + 2.89477880583686i	-2.26353790425539 + 0.991711449320438i	-1.59926956150946 - 1.26591845112272i	-1.82727941080067 + 1.40888826617797i	3.19339107231927 - 1.54622026795331i	-0.769243213538278 + 0.00000000000000i	3.19339107231927 + 1.54622026795331i	-1.82727941080067 - 1.40888826617797i	-1.59926956150946 + 1.26591845112272i	-2.26353790425539 - 0.991711449320438i	-0.228744126780665 - 2.89477880583686i	-3.69406959265168 - 2.13615561430979i	0.376246798847378 - 0.895446879090657i	-0.193106604192182 + 0.967434476506570i	-2.45040875763492 + 2.17708811713246i	1.45437797145914 + 0.374414601180126i	1.99945612556177 + 0.956895757453615i	-1.25211463612889 - 0.875583758727025i	2.40905461788825 + 0.396050137265195i	1.81098334556302 - 0.143977389053291i	-1.67813971614456 + 0.978004277157783i	0.817796364815585 + 0.309707024348210i	0.447819021167126 - 3.33503556085975i	0.155572955829434 - 1.55773538196422i	1.74947644652770 - 0.944017569300557i	-0.0841990783480326 + 2.19317445383265i	2.20981585489899 + 1.97046476067149i	1.70013864954576 - 1.77578688515317i	0.461676582810861 + 1.32026551934167i	-0.0815223578179583 - 0.945616250359873i	-0.264071761278926 + 0.431653669711722i	-2.72015730531285 + 1.08259050424059i	-0.273998419566102 - 4.28316854094621i	-0.212349451108356 + 1.14693228377951i	-0.142808450511818 - 0.239642689082386i	-1.48465071113273 + 0.819634065690065i	-1.13101735688985 - 0.406729449475790i

        // check that length is a power of 2
        int N = x.length;
        if (Integer.highestOneBit(N) != N)
            throw new RuntimeException("N is not a power of 2");

        // bit reversal permutation
        for (int k = 0; k < N; k++) {
            int shift = 1 + Integer.numberOfLeadingZeros(N);

            int j = Integer.reverse(k) >>> shift;
            if (j > k) {
                Complex temp = x[j];
                x[j] = x[k];
                x[k] = temp;
            }
        }

        Complex[] tmp, out = Arrays.copyOf(x, x.length);
        Complex[] in = new Complex[x.length];

        System.out.println("x:" + Arrays.toString(x));
        int numPasses = (int) Math.round(Math.log(N) / Math.log(2));

        for (int pass = 0; pass < numPasses; pass++) {
            System.out.println("pass: " + pass);
            int L = (int) Math.pow(2, pass + 1);

            for (int k = 0; k < L / 2; k++) {
                double kth = -2 * k * Math.PI / L;
                Complex w = new Complex((float) Math.cos(kth), (float) Math.sin(kth));

                for (int j = 0; j < N / L; j++) {
                    Complex tao = w.times(x[j * L + k + L / 2]);
                    x[j * L + k + L / 2] = x[j * L + k].minus(tao);
                    x[j * L + k] = x[j * L + k].plus(tao);
                }
            }

            System.out.println("x:" + Arrays.toString(x));
        }

        System.out.println("out:" + Arrays.toString(out));
        for (int pass = 0; pass < numPasses; pass++) {
            System.out.println("pass: " + pass);
            tmp = in;
            in = out;
            out = tmp;
            int passBit = 1 << pass;
            int fftWidth = passBit * 2;

            for (int gid = 0; gid < N; gid++) {
                int first = gid & (~passBit);
                int second = gid | passBit;
                int signum = (gid == first) ? 1 : -1;

                assert first == gid || second == gid;

                int kthButterly = pass == 0 ? 0 : gid % (fftWidth / 2);
                double kthAngle = -2 * kthButterly * Math.PI / fftWidth;
                Complex w = new Complex((float) Math.cos(kthAngle), (float) Math.sin(kthAngle));

                out[gid] = in[first].plus(in[second].times(w).times(signum));
            }

            System.out.println("out:" + Arrays.toString(out));
        }


    }

    public static void main(String[] args) {
        int N = 64;
        Complex[] x = new Complex[N];

        // original data
        for (int i = 0; i < N; i++)
            x[i] = new Complex((float) (-2 * Math.random() + 1), 0);

        fft(x);

    }

}
